/**
 * Use this class to generate commands to populate the system with test data.
 */
import {PopulatorSequenceElement} from "../interface/populator-sequence-element.interface";
import {Dictionary} from "../../base/type/dictionary.type";
import {SeededFunction} from "../type/seeded-function.type";
import {uuid} from "../../base/type/uuid.type";
import {Command} from "../interface/command.interface";
import {Predicate} from "../type/predicate.type";
import {CommandDefinition} from "../interface/command-definition.interface";
import {CommandRunner} from "./command-runner.class";
import {range} from "lodash";
import {DistributionGenerator} from "../generator/distribution-generator";
import {GetFromListGenerator} from "../generator/get-from-list-generator";
import {AbstractSimpleDataGenerator} from "../generator/abstract-simple-data-generator";
import {LogLevel} from "../../modules/core/log";
import chalk from "chalk";

const seedrandom = require("seedrandom");

export class Populator implements PopulatorSequenceElement {

    /**
     * The seed which is used to create deterministic values. When using the same seed, the populator uses the same data.
     */
    public readonly seed: string;

    private queue: PopulatorSequenceElement[] = [];

    private asyncGenerators: AbstractSimpleDataGenerator<any>[] = [];

    /**
     * Defined generators to use in the populator.
     */
    private generators: Dictionary<SeededFunction<any>> = {};

    /**
     * The values generated by the generator functions in each iteration.
     */
    private values: Dictionary<any> = {};

    /**
     * The results of the executed commands.
     */
    private results: Dictionary<string> = {};

    /**
     * The minimum amount of iterations the sequences should be executed.
     */
    protected timesMinimum: number = 1;

    /**
     * The maximum amount of iterations the sequences should be executed.
     */
    protected timesMaximum: number = 1;


    constructor(seed: string = "default") {
        this.seed = seed;
    }

    public static randomInt(seed: string, min: number, max: number): number {
        return Math.floor(seedrandom(seed)() * (max - min) + min);
    }

    /**
     * Creates a generator for distributing a given list of elements based on the given distributions.
     *
     * @param distributions A map of elements to distribute as keys and the distribution value as value.
     * @return A generator function of a {@link DistributionGenerator}.
     */
    public static distribution<TYPE>(distributions: TYPE[] | [TYPE, number][]): SeededFunction<TYPE> {
        let distribution: DistributionGenerator<TYPE>;
        if (!Array.isArray(distributions[0])) {
            distribution = new DistributionGenerator<TYPE>((distributions as TYPE[]).map(d => [d, 1]));
        } else {
            distribution = new DistributionGenerator<TYPE>(distributions as [TYPE, number][]);
        }
        return seed => distribution.generate(seed);
    }


    /**
     * Creates a generator to pick values from the list one after another.
     *
     * @param values The list of values to pick from.
     * @return A generator function of a {@link GetFromListGenerator}.
     */
    public static getFromList<TYPE>(values: TYPE[]): SeededFunction<TYPE> {
        const generator: GetFromListGenerator<TYPE> = new GetFromListGenerator<TYPE>(values);
        return seed => generator.generate(seed);
    }

    public registerAsyncGenerator(generator: AbstractSimpleDataGenerator<any>): Populator {
        this.asyncGenerators.push(generator);
        return this;
    }

    /**
     * Define a generator function that generates a new value in each iteration based on the given iteration seed.
     */
    public define(variableName: string, generator: SeededFunction<any>): Populator {
        this.generators[variableName] = generator;
        return this;
    }


    /**
     * Get a value from a variable set by {@link Populator::define}.
     */
    public get<TYPE>(key: string): TYPE {
        return this.values[key] as TYPE;
    }

    /**
     * Get a result from a previously executed command.
     * @param commandName {string} The command name to get the result from.
     */
    public getResult(commandName: string): string {
        return this.results[commandName];
    }

    /**
     * Returns the generator with the given key, previously defined with {@link Populator::defineGenerator}.
     */
    public getGenerator<TYPE>(key: string): SeededFunction<TYPE> {
        return this.generators[key];
    }

    public command(objectIdSupplier: SeededFunction<uuid> | uuid | undefined,
                   commandSupplier: SeededFunction<Command>,
                   shouldExecute?: Predicate,
                   name?: string): Populator {
        const commandDefinition: CommandDefinition = new CommandDefinition(
            typeof objectIdSupplier === "string" ? () => objectIdSupplier : objectIdSupplier,
            commandSupplier,
            shouldExecute,
            name,
        );
        this.queue.push(commandDefinition);
        return this;
    }

    public times(min?: number,
                 max?: number): Populator {
        this.timesMinimum = min ?? 0;
        this.timesMaximum = max ?? min ?? 0;
        return this;
    }

    public sequence(sequenceFunction: (populator: Populator) => Populator): Populator {
        this.queue.push(sequenceFunction.apply(this, [new Populator(this.seed + this.queue.length)]));
        return this;
    }

    private reset(): void {
        this.generators = {};
        this.queue = [];
        this.values = {};
    }

    public async run(commandRunner: CommandRunner): Promise<void> {
        const time: number = new Date().getTime();
        this.log("Populating..");
        try {
            await this.populate(commandRunner, this.seed);
        } catch (e) {
            console.log(e);
            this.log(e.message, LogLevel.ERROR);
        }
        const timeNeeded = new Date().getTime() - time;
        this.log(`Job done in ${timeNeeded} ms.`);
        this.reset();
    }

    protected async populate(commandRunner: CommandRunner, seed: string): Promise<void> {
        const iterations: number = Populator.randomInt(seed, this.timesMinimum, this.timesMaximum);
        return Promise.all(range(0, iterations).map(i => this.runIteration(this.seed, commandRunner, i, iterations))).then(() => {
            return;
        });
    }

    private async runIteration(seed: string, commandRunner: CommandRunner, i: number, total: number): Promise<void> {
        const iterationSeed = `${seed} ${i}`;
        let generatorIndex: number = 0;
        Object.entries(this.generators).forEach(([key, generator]) => {
            this.values[key] = generator(`${iterationSeed} ${generatorIndex}`);
        });

        let execution: number = 0;

        for (const populatorSequenceElement of this.queue) {
            const executionSeed: string = `${iterationSeed} ${execution}`;
            if (populatorSequenceElement instanceof CommandDefinition) {
                try {
                    const result: string | undefined = await commandRunner.execute(populatorSequenceElement, executionSeed);
                    if (result !== undefined) {
                        if (populatorSequenceElement.name) {
                            this.results[populatorSequenceElement.name] = result;
                        }
                        this.log(`Executed ${result} ${i + 1} / ${total}`);
                    }
                } catch (e) {
                    this.log(`Failed ${e.message}`, LogLevel.ERROR);
                }
            } else if (populatorSequenceElement instanceof Populator) {
                await populatorSequenceElement.populate(commandRunner, executionSeed);
            }
            execution++;
        }
    }

    private log(message: string, level: LogLevel = LogLevel.INFO) {
        const logColors: Dictionary<Function, LogLevel> = {
            [LogLevel.INFO]: chalk.blueBright,
            [LogLevel.WARN]: chalk.yellow,
            [LogLevel.ERROR]: chalk.red,
        };
        let color: Function = logColors[level] ?? chalk.blueBright;
        console.log(color(message));
    }
}
